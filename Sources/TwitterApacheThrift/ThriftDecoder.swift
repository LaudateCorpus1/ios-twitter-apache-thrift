// Copyright 2020 Twitter, Inc.
// Licensed under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0
//
//  ThriftDecoder.swift
//  TwitterApacheThrift
//
//  Created on 3/24/20.
//  Copyright Â© 2020 Twitter, Inc. All rights reserved.
//

import Foundation

/// Provide a default implementation which calls through to `Decodable`. This
/// allows `ThriftDecodable` to use the `Decodable` implementation generated by the
/// compiler.
public extension ThriftDecodable {
    init(fromThrift decoder: ThriftDecoder) throws {
        try self.init(from: decoder)
        let (nextField, _) = try decoder.readFieldAndId()
        if nextField == .stop {
            //Read the struct stop
            _ = try decoder.binary?.readByte()
        }
    }
}

/// Errors thrown when the thrift is decoded.
public enum ThriftDecoderError: Error {
    /// The key of the field is not the next key in the thrift, possibly because
    /// of malformed thrift data or model discrepancy
    case keyOrderMismatch
    /// Internal buffer is uninitialized should only happen if using methods
    /// other then `decode<T>(_ type: T.Type, from data: Data)` for decoding
    case uninitializedDecodingData
    /// CodingKey is missing the value
    case codingKeyMissingIntValue(key: CodingKey)
    /// The type is not encodable, example not conforming to ThriftDecodable
    case undecodableType(type: Any)
    /// The string found while decoding is not UTF8 formmated, possibly because
    /// of malformed thrift or an encoding error.
    case nonUTF8StringData(Data)
    /// The buffer overflowed while trying to read a field, possibly because
    /// of using the wrong model type
    case readBufferOverflow
    /// The thrift data has a unsupported type value
    case unsupportedThriftType
}

///An object that decodes instances of a data type from Thrift objects.
public class ThriftDecoder: Decoder {
    public var codingPath: [CodingKey] = []

    public var userInfo: [CodingUserInfoKey : Any] = [:]

    fileprivate var binary: ThriftBinary?

    /// Initializes `self` with defaults.
    public init() {}

    /// Decodes a top-level value of the given type from the given Thrift representation.
    ///
    /// - parameter type: The type of the value to decode.
    /// - parameter data: The data to decode from.
    /// - returns: A value of the requested type.
    /// - throws: An `ThriftDecoderError` if any value throws an error during decoding.
    public func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : ThriftDecodable {
        self.binary = ThriftBinary(data: data)
        return try type.init(fromThrift: self)
    }

    public func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : CodingKey {
        return KeyedDecodingContainer(KeyedContainer<Key>(decoder: self))
    }

    public func unkeyedContainer() throws -> UnkeyedDecodingContainer {
        return UnkeyedContainer(decoder: self)
    }

    public func singleValueContainer() throws -> SingleValueDecodingContainer {
        return UnkeyedContainer(decoder: self)
    }

    private struct KeyedContainer<Key: CodingKey>: KeyedDecodingContainerProtocol {
        var allKeys: [Key] = []

        var decoder: ThriftDecoder

        var codingPath: [CodingKey] { return [] }

        func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
            return try decoder.container(keyedBy: type)
        }

        func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
            return try decoder.unkeyedContainer()
        }

        func superDecoder() -> Decoder {
            return decoder
        }

        func superDecoder(forKey key: Key) throws -> Decoder {
            return decoder
        }

        func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Decodable {
            return try decoder.decode(type, forKey: key)
        }

        func contains(_ key: Key) -> Bool {
            return (try? decoder.isNull(forKey: key)) == false
        }

        func decodeNil(forKey key: Key) throws -> Bool {
            return try decoder.isNull(forKey: key)
        }
    }

    private struct UnkeyedContainer: UnkeyedDecodingContainer, SingleValueDecodingContainer {
        var decoder: ThriftDecoder

        var codingPath: [CodingKey] { return [] }

        var count: Int? { return nil }

        var currentIndex: Int { return 0 }

        var isAtEnd: Bool { return false }

        mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
            return try decoder.container(keyedBy: type)
        }

        func nestedUnkeyedContainer() -> UnkeyedDecodingContainer {
            return self
        }

        func superDecoder() -> Decoder {
            return decoder
        }

        func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
            return try decoder.decodeType(type: type)
        }

        func decodeNil() -> Bool {
            return true
        }
    }
}

extension ThriftDecoder {
    private func decode<T: Decodable, Key: CodingKey>(_ type: T.Type, forKey key: Key) throws -> T {
        self.codingPath.append(key)
        defer {
            self.codingPath.removeLast()
        }

        guard let binary = self.binary else {
            throw ThriftDecoderError.uninitializedDecodingData
        }
        guard let keyId = key.intValue else {
            throw ThriftDecoderError.codingKeyMissingIntValue(key: key)
        }

        let (fieldType, id) = try binary.readFieldMetadata()

        if id != keyId {
            if fieldType == .stop || id == nil {
                return try decode(type, forKey: key)
            }
            throw ThriftDecoderError.keyOrderMismatch
        }

        return try decodeType(type: type)
    }

    private func isNull<Key: CodingKey>(forKey key: Key) throws -> Bool {
        guard let keyId = key.intValue else {
            throw ThriftDecoderError.codingKeyMissingIntValue(key: key)
        }

        let (_, id) = try readFieldAndId()
        return (id != keyId)
    }

    fileprivate func readFieldAndId() throws -> (ThriftType, Int?) {
        guard let binary = self.binary else {
            throw ThriftDecoderError.uninitializedDecodingData
        }

        let (fieldType, id) = try binary.readFieldMetadata()

        if fieldType == .stop {
            binary.moveReadCursorBackAfterType()
        } else {
            binary.moveReadCursorBackAfterTypeAndFieldID()
        }

        return (fieldType, id)
    }

    private func decodeType<T: Decodable>(type: T.Type) throws -> T {
        guard let binary = self.binary else {
            throw ThriftDecoderError.uninitializedDecodingData
        }

        let decoded: T?

        switch type {
        case is Bool.Type:
            decoded = try binary.readBool() as? T
        case is Data.Type:
            decoded = try binary.readBinary() as? T
        case is Double.Type:
            decoded = try binary.readDouble() as? T
        case is UInt8.Type:
            decoded = try binary.readByte() as? T
        case is Int16.Type:
            decoded = try binary.readInt16() as? T
        case is Int32.Type:
            decoded = try binary.readInt32() as? T
        case is Int64.Type:
            decoded = try binary.readInt64() as? T
        case is String.Type:
            decoded = try binary.readString() as? T
        case let thriftDecodable as ThriftDecodable.Type:
            decoded = try thriftDecodable.init(fromThrift: self) as? T
        default:
            decoded = nil
        }

        guard let typedDecoded = decoded else {
            throw ThriftDecoderError.undecodableType(type: type)
        }

        return typedDecoded
    }
}


extension Dictionary : ThriftDecodable where Key: Decodable, Value: Decodable {
    public init(fromThrift decoder: ThriftDecoder) throws {
        guard let binary = decoder.binary else {
            throw ThriftDecoderError.uninitializedDecodingData
        }
        let (_, _, size) = try binary.readMapMetadata()
        var container = try decoder.unkeyedContainer()
        self.init(minimumCapacity: size)
        for _ in 0..<size {
            let key = try container.decode(Key.self)
            let value = try container.decode(Value.self)
            self[key] = value
        }
    }
}

extension Set: ThriftDecodable where Element: Decodable {
    public init(fromThrift decoder: ThriftDecoder) throws {
        guard let binary = decoder.binary else {
            throw ThriftDecoderError.uninitializedDecodingData
        }

        let (_, size) = try binary.readSetMetadata()
        var container = try decoder.unkeyedContainer()
        self.init(minimumCapacity: Int(size))
        for _ in 0..<size {
            let value = try container.decode(Element.self)
            self.insert(value)
        }
    }
}

extension Array: ThriftDecodable where Element: Decodable {
    public init(fromThrift decoder: ThriftDecoder) throws {
        guard let binary = decoder.binary else {
            throw ThriftDecoderError.uninitializedDecodingData
        }

        let (_, size) = try binary.readListMetadata()
        var container = try decoder.unkeyedContainer()
        self.init()
        self.reserveCapacity(Int(size))
        for _ in 0..<size {
            let value = try container.decode(Element.self)
            self.append(value)
        }
    }
}

extension PreencodedContainer: ThriftDecodable {

    public init(fromThrift decoder: ThriftDecoder) throws {
        try self.init(from: decoder)
    }

    public init(from decoder: Decoder) throws {
        self = .value(try T(from: decoder))
    }
}
